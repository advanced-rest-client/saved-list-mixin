<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>saved-list-mixin test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <!-- Required by the request model -->
  <script src="../../../pouchdb-quick-search/dist/pouchdb.quick-search.min.js"></script>

</head>
<body>

  <test-fixture id="Basic">
    <template>
      <request-model></request-model>
      <test-element no-auto></test-element>
    </template>
  </test-fixture>

  <test-fixture id="QueryLimit">
    <template>
      <request-model></request-model>
      <test-element no-auto page-limit="10"></test-element>
    </template>
  </test-fixture>

  <test-fixture id="NoModel">
    <template>
      <test-element no-auto page-limit="10"></test-element>
    </template>
  </test-fixture>

  <test-fixture id="WithIndexer">
    <template>
      <request-model></request-model>
      <url-indexer></url-indexer>
      <test-element no-auto></test-element>
    </template>
  </test-fixture>

  <script type="module">
  import '../../../@advanced-rest-client/arc-models/request-model.js';
  import '../../../@advanced-rest-client/arc-models/url-indexer.js';
  import {DataGenerator} from '../../../@advanced-rest-client/arc-data-generator/arc-data-generator.js';
  import './test-element.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';

  suite('saved-list-mixin', () => {
    suite('queryOptions computations', () => {
      test('Sets default query limit', () => {
        const element = fixture('Basic')[1];
        assert.typeOf(element.queryOptions, 'object', 'queryOptions is computed');
        assert.equal(element.queryOptions.limit, 150);
      });

      test('Respects page-limit attribute', () => {
        const element = fixture('QueryLimit')[1];
        assert.equal(element.queryOptions.limit, 10);
      });

      test('Sets startkey property', () => {
        const element = fixture('Basic')[1];
        element._queryStartKey = 'test';
        assert.equal(element.queryOptions.startkey, 'test');
      });

      test('Sets skip property', () => {
        const element = fixture('Basic')[1];
        element._querySkip = 1;
        assert.equal(element.queryOptions.skip, 1);
      });

      test('Sets descending property', () => {
        const element = fixture('Basic')[1];
        assert.isTrue(element.queryOptions.descending);
      });

      test('Sets include_docs property', () => {
        const element = fixture('Basic')[1];
        assert.isTrue(element.queryOptions.include_docs);
      });
    });

    suite('_computeQueryOptions()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Sets descending property', () => {
        const result = element._computeQueryOptions();
        assert.isTrue(result.descending);
      });

      test('Sets include_docs property', () => {
        const result = element._computeQueryOptions();
        assert.isTrue(result.include_docs);
      });

      test('Sets limit', () => {
        const result = element._computeQueryOptions(10);
        assert.equal(result.limit, 10);
      });

      test('Sets startkey property', () => {
        const result = element._computeQueryOptions(10, 'test');
        assert.equal(result.startkey, 'test');
      });

      test('Sets skip property', () => {
        const result = element._computeQueryOptions(10, 'test', 1);
        assert.equal(result.skip, 1);
      });
    });

    suite('_computeDataUnavailable()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Returns true if all undefined', () => {
        const result = element._computeDataUnavailable();
        assert.isTrue(result);
      });

      test('Returns true if all false', () => {
        const result = element._computeDataUnavailable(false, false, false);
        assert.isTrue(result);
      });

      test('Returns false if hasRequests is true', () => {
        const result = element._computeDataUnavailable(true, false, false);
        assert.isFalse(result);
      });

      test('Returns false if loading is true', () => {
        const result = element._computeDataUnavailable(false, true, false);
        assert.isFalse(result);
      });

      test('Returns false if isSearch is true', () => {
        const result = element._computeDataUnavailable(false, false, true);
        assert.isFalse(result);
      });
    });

    suite('_computeSearchListEmpty()', () => {
      let element;
      suiteSetup(() => {
        element = fixture('Basic')[1];
      });

      test('Returns false if all undefined', () => {
        const result = element._computeSearchListEmpty();
        assert.isFalse(result);
      });

      test('Returns false if all false', () => {
        const result = element._computeSearchListEmpty(false, false, false);
        assert.isFalse(result);
      });

      test('Returns false if hasRequests is true', () => {
        const result = element._computeSearchListEmpty(true, false, false);
        assert.isFalse(result);
      });

      test('Returns false if loading is true', () => {
        const result = element._computeSearchListEmpty(false, true, false);
        assert.isFalse(result);
      });

      test('Returns true if isSearch is true', () => {
        const result = element._computeSearchListEmpty(false, false, true);
        assert.isTrue(result);
      });
    });

    suite('_dataImportHandler()', () => {
      let element;
      setup(() => {
        element = fixture('Basic')[1];
      });

      test('Calls refresh() when called', () => {
        let called = false;
        element.refresh = () => called = true;
        element._dataImportHandler();
        assert.isTrue(called);
      });

      test('Calls refresh() when data-imported is handled', () => {
        let called = false;
        element.refresh = () => called = true;
        document.body.dispatchEvent(new CustomEvent('data-imported', {
          bubbles: true
        }));
        assert.isTrue(called);
      });
    });

    suite('_onDatabaseDestroy()', () => {
      let element;
      setup(() => {
        element = fixture('Basic')[1];
      });

      test('Calls refresh() when called with "saved" datastore', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['saved']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when called with "saved-requests" datastore (legacy api)', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['saved-requests']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when called with "all" datastore', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: ['saved-requests']
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when datastore is a string', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: 'saved-requests'
          }
        });
        assert.isTrue(called);
      });

      test('Calls refresh() when datastore-destroyed is handled', () => {
        let called = false;
        element.refresh = () => called = true;
        document.body.dispatchEvent(new CustomEvent('datastore-destroyed', {
          bubbles: true,
          detail: {
            datastore: ['saved']
          }
        }));
        assert.isTrue(called);
      });

      test('Do nothing when datastore not set', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {}
        });
        assert.isFalse(called);
      });

      test('Do nothing when datastore is not an array', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: true
          }
        });
        assert.isFalse(called);
      });

      test('Do nothing when datastore is history store', () => {
        let called = false;
        element.refresh = () => called = true;
        element._onDatabaseDestroy({
          detail: {
            datastore: 'history'
          }
        });
        assert.isFalse(called);
      });
    });

    suite('_processRequestsResponse()', function() {
      let element;
      let data;
      setup(function() {
        element = fixture('Basic')[1];
        data = [{
          _id: '1',
          name: 'b'
        }, {
          _id: '2',
          name: 'a'
        }];
      });

      test('Do nothing if no items', function() {
        const result = element._processRequestsResponse();
        assert.isUndefined(result);
      });

      test('Do nothing when empty items', function() {
        const result = element._processRequestsResponse([]);
        assert.isUndefined(result);
      });

      test('Returns a list of documents', function() {
        const result = element._processRequestsResponse(data);
        assert.typeOf(result, 'array');
        assert.lengthOf(result, 2);
      });

      test('Documents are sorted by name', function() {
        const result = element._processRequestsResponse(data);
        assert.equal(result[0]._id, '2');
        assert.equal(result[1]._id, '1');
      });

      test('Ignores empty items', function() {
        data.splice(1, 0, undefined);
        const result = element._processRequestsResponse(data);
        assert.lengthOf(result, 2);
      });

      test('Transforms PouchDB item.doc to doc', function() {
        data[0] = {
          doc: data[0]
        };
        const result = element._processRequestsResponse(data);
        assert.equal(result[0]._id, '2');
      });

      test('Ignores PouchDB _design items', function() {
        data[0]._id = '_design';
        const result = element._processRequestsResponse(data);
        assert.lengthOf(result, 1);
      });
    });

    suite('_sortSavedResults()', () => {
      let element;
      let data;
      setup(function() {
        element = fixture('Basic')[1];
        data = [{
          _id: '1',
          name: 'c'
        }, {
          _id: '2',
          name: 'a'
        }, {
          _id: '3',
          name: 'b'
        }];
      });

      test('Sorts the array', () => {
        data.sort(element._sortSavedResults);
        assert.equal(data[0]._id, '2');
        assert.equal(data[1]._id, '3');
        assert.equal(data[2]._id, '1');
      });

      test('Returns 0 when times equal', () => {
        const a = {
          name: 'a'
        };
        const b = {
          name: 'a'
        };
        const result = element._sortSavedResults(a, b);
        assert.equal(result, 0);
      });

      test('Returns -1 when A time is higher', () => {
        const a = {
          name: 'b'
        };
        const b = {
          name: 'a'
        };
        const result = element._sortSavedResults(a, b);
        assert.equal(result, 1);
      });

      test('Returns 1 when B time is higher', () => {
        const a = {
          name: 'a'
        };
        const b = {
          name: 'b'
        };
        const result = element._sortSavedResults(a, b);
        assert.equal(result, -1);
      });

      test('Returns -1 when A is missing name', () => {
        const a = {};
        const b = {
          name: 'b'
        };
        const result = element._sortSavedResults(a, b);
        assert.equal(result, -1);
      });

      test('Returns 1 when B is missing name', () => {
        const a = {
          name: 'b'
        };
        const b = {};
        const result = element._sortSavedResults(a, b);
        assert.equal(result, 1);
      });

      test('Returns 0 when A and B is missing name', () => {
        const a = {};
        const b = {};
        const result = element._sortSavedResults(a, b);
        assert.equal(result, 0);
      });
    });

    suite('_appendItems()', function() {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Adds items to the list that doesn\'t exists', function() {
        const items = [{
          _id: 1
        }, {
          _id: 2
        }];
        assert.isUndefined(element.requests);
        element._appendItems(items);
        assert.typeOf(element.requests, 'array');
        assert.lengthOf(element.requests, 2);
      });

      test('Adds items to the list that already exists', function() {
        const requests = [{
          _id: 1
        }, {
          _id: 2
        }];
        element.requests = [{
          _id: 3
        }];
        element._appendItems(requests);
        assert.typeOf(element.requests, 'array');
        assert.lengthOf(element.requests, 3);
      });
    });

    function cancelRequestListEvent(element, requests) {
      if (!requests) {
        requests = [];
      }
      element.addEventListener('request-list', function f(e) {
        element.removeEventListener('request-list', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          rows: requests
        });
      });
    }

    suite('refresh()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Calles reset() function', () => {
        let called = false;
        element.reset = () => called = true;
        element.loadNext = () => {};
        element.refresh();
        assert.isTrue(called);
      });

      test('Calles loadNext() function', () => {
        let called = false;
        element.reset = () => {};
        element.loadNext = () => called = true;
        element.refresh();
        assert.isTrue(called);
      });
    });

    suite('reset()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Resets _queryStartKey', () => {
        element._queryStartKey = 'test';
        element.reset();
        assert.isUndefined(element._queryStartKey);
      });

      test('Resets _querySkip', () => {
        element._querySkip = 1;
        element.reset();
        assert.isUndefined(element._querySkip);
      });

      test('Resets requests', () => {
        element.requests = [{}];
        element.reset();
        assert.isUndefined(element.requests);
      });

      test('Resets isSearch', () => {
        element.isSearch = true;
        element.reset();
        assert.isFalse(element.isSearch);
      });

      test('Resets querying', () => {
        element._setQuerying(true);
        element.reset();
        assert.isFalse(element.querying);
      });
    });

    suite('loadNext()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Eventually calls _loadPage()', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.loadNext();
        afterNextRender(element, () => {
          assert.isTrue(called);
          done();
        });
      });

      test('Sets __makingQuery flag', (done) => {
        element._loadPage = () => done();
        element.loadNext();
        assert.isTrue(element.__makingQuery);
      });

      test('Clears __makingQuery flag after callback', (done) => {
        element._loadPage = () => {
          assert.isFalse(element.__makingQuery);
          done();
        };
        element.loadNext();
      });

      test('Do nothing when __makingQuery flag is set', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.__makingQuery = true;
        element.loadNext();
        afterNextRender(element, () => {
          assert.isFalse(called);
          done();
        });
      });

      test('Do nothing when isSearch flag is set', (done) => {
        let called = false;
        element._loadPage = () => called = true;
        element.isSearch = true;
        element.loadNext();
        afterNextRender(element, () => {
          assert.isFalse(called);
          done();
        });
      });
    });

    suite('_dispatchListEvent()', () => {
      let element;
      setup(function() {
        element = fixture('Basic')[1];
      });

      test('Dispatches "request-list" custom event', () => {
        let called = false;
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          called = true;
        });
        element._dispatchListEvent();
        assert.isTrue(called);
      });

      test('Returns custom event', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result, 'customevent');
      });

      test('Custom event has detail object', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result.detail, 'object');
      });

      test('Detail contains type', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.equal(result.detail.type, 'saved');
      });

      test('Detail contains queryOptions', () => {
        cancelRequestListEvent(element);
        const result = element._dispatchListEvent();
        assert.typeOf(result.detail.queryOptions, 'object');
      });
    });

    suite('_loadPage()', () => {
      suiteSetup(() => {
        return DataGenerator.insertSavedRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroySavedRequestData();
      });

      test('Does nothing when isSearch is set', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element._loadPage();
        assert.isUndefined(element.querying);
        return p;
      });

      test('Returns promise', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element._loadPage();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Dispatches "request-list" custom event', () => {
        const element = fixture('Basic')[1];
        let called = false;
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          called = true;
          e.detail.result = Promise.resolve({
            rows: []
          });
        });
        const p = element._loadPage();
        assert.isTrue(called);
        return p;
      });

      test('Rejects when event is not handled', (done) => {
        const element = fixture('NoModel');
        let called = false;
        element._loadPage()
        .then(() => {
          done(new Error('Not rejected promise'));
          called = true;
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets querying property', () => {
        const element = fixture('NoModel');
        cancelRequestListEvent(element);
        const p = element._loadPage();
        assert.isTrue(element.querying);
        return p;
      });

      test('Resets querying when ready', () => {
        const element = fixture('NoModel');
        cancelRequestListEvent(element);
        const p = element._loadPage();
        return p.then(() => {
          assert.isFalse(element.querying);
        });
      });

      test('Resets querying when error', (done) => {
        const element = fixture('NoModel');
        element.addEventListener('request-list', function f(e) {
          element.removeEventListener('request-list', f);
          e.preventDefault();
          e.detail.result = Promise.reject(new Error('test'));
        });
        let called = false;
        element._loadPage().then(() => {
          called = true;
          done(new Error('Should not succeed'));
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets requests from the response', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.typeOf(element.requests, 'array');
          assert.lengthOf(element.requests, 25);
        });
      });

      test('Sets _queryStartKey', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.typeOf(element._queryStartKey, 'string');
        });
      });

      test('Sets _querySkip', () => {
        const element = fixture('Basic')[1];
        return element._loadPage()
        .then(() => {
          assert.equal(element._querySkip, 1);
        });
      });

      test('Calls _processRequestsResponse() for documents', () => {
        let called = false;
        const element = fixture('Basic')[1];
        element._processRequestsResponse = () => called = true;
        return element._loadPage()
        .then(() => {
          assert.isTrue(called);
        });
      });

      test('Calls notifyResize when defined', (done) => {
        let called = false;
        const element = fixture('Basic')[1];
        element.notifyResize = () => called = true;
        element._loadPage()
        .then(() => {
          afterNextRender(element, () => {
            assert.isTrue(called);
            done();
          });
        });
      });
    });

    suite('_handleError()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Throws an error', () => {
        assert.throws(function() {
          element._handleError(new Error('test'));
        });
      });

      test('Resets "querying" flag', () => {
        element._setQuerying(true);
        try {
          element._handleError(new Error('test'));
        } catch (_) {}
        assert.isFalse(element.querying);
      });
    });

    function cancelRequestQueryEvent(element, requests) {
      if (!requests) {
        requests = [];
      }
      element.addEventListener('request-query', function f(e) {
        element.removeEventListener('request-query', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          rows: requests
        });
      });
    }

    suite('_dispatchQueryEvent()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Dispatches "request-query" custom event', () => {
        let called = false;
        element.addEventListener('request-query', function f(e) {
          element.removeEventListener('request-query', f);
          e.preventDefault();
          called = true;
        });
        element._dispatchQueryEvent();
        assert.isTrue(called);
      });

      test('Returns custom event', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.typeOf(result, 'customevent');
      });

      test('Custom event has detail object', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.typeOf(result.detail, 'object');
      });

      test('Detail contains "type"', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent();
        assert.equal(result.detail.type, 'saved');
      });

      test('Detail contains "q"', () => {
        cancelRequestQueryEvent(element);
        const result = element._dispatchQueryEvent('test');
        assert.equal(result.detail.q, 'test');
      });
    });

    suite('query()', () => {
      suiteSetup(() => {
        return DataGenerator.insertSavedRequestData();
      });

      suiteTeardown(() => {
        return DataGenerator.destroySavedRequestData();
      });

      test('Does nothing when query is not set', () => {
        const element = fixture('Basic')[1];
        const p = element.query();
        assert.isUndefined(element.querying);
        return p;
      });

      test('Returns a promise when query is not set', () => {
        const element = fixture('Basic')[1];
        const p = element.query();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Returns promise when query is not set and isSearch', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        const p = element.query();
        assert.typeOf(p.then, 'function');
        return p;
      });

      test('Calls refresh() when query is not set and isSearch', () => {
        const element = fixture('Basic')[1];
        element.isSearch = true;
        let called = false;
        element.refresh = () => called = true;
        const p = element.query();
        assert.isTrue(called);
        return p;
      });

      test('Dispatches "request-query" custom event', () => {
        const element = fixture('Basic')[1];
        let called = false;
        element.addEventListener('request-query', function f(e) {
          element.removeEventListener('request-query', f);
          e.preventDefault();
          called = true;
          e.detail.result = Promise.resolve([]);
        });
        const p = element.query('test');
        assert.isTrue(called);
        return p;
      });

      test('Rejects when event is not handled', (done) => {
        const element = fixture('NoModel');
        let called = false;
        element._loadPage()
        .then(() => {
          done(new Error('Not rejected promise'));
          called = true;
        })
        .catch(() => {
          if (!called) {
            done();
          }
        });
      });

      test('Sets querying property', () => {
        const element = fixture('NoModel');
        cancelRequestQueryEvent(element);
        const p = element.query('test');
        assert.isTrue(element.querying);
        return p;
      });

      test('Resets querying when ready', () => {
        const element = fixture('NoModel');
        cancelRequestQueryEvent(element);
        const p = element.query('test');
        return p.then(() => {
          assert.isFalse(element.querying);
        });
      });
    });

    suite('_prepareQuery()', () => {
      let element;
      setup(function() {
        element = fixture('NoModel');
      });

      test('Transforms query to string', () => {
        const result = element._prepareQuery(1);
        assert.typeOf(result, 'string');
        assert.equal(result, '1');
      });

      test('Transforms query to lower case', () => {
        const result = element._prepareQuery('CaR');
        assert.equal(result, 'car');
      });

      test('Removes first underscore', () => {
        const result = element._prepareQuery('_test');
        assert.equal(result, 'test');
      });
    });
  });
  </script>
</body>
</html>
